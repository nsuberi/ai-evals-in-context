name: AI Application CI/CD

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main]

env:
  TSR_API_URL: ${{ secrets.TSR_API_URL || 'http://localhost:5000' }}

jobs:
  test-and-evaluate:
    runs-on: ubuntu-latest
    outputs:
      decision: ${{ steps.go_no_go.outputs.decision }}
      tsr_id: ${{ steps.tsr.outputs.tsr_id }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git operations

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Start Docker Compose services
        working-directory: ./ai-testing-resource
        run: |
          cp .env.docker .env
          echo "ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}" >> .env
          docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d

      - name: Wait for services to be healthy
        working-directory: ./ai-testing-resource
        run: |
          echo "Waiting for all services to be healthy..."
          timeout 300 bash -c 'until [ $(docker compose ps --format json | jq -r "select(.Health == \"healthy\") | .Name" | wc -l) -eq 3 ]; do echo "Waiting for all 3 services to be healthy..."; docker compose ps; sleep 5; done'
          echo "All services are healthy!"
          docker compose ps

      - name: Generate TSR from test results
        id: tsr
        working-directory: ./ai-testing-resource
        run: |
          # Tests run automatically via docker-compose.ci.yml command
          # Just generate TSR from existing results
          docker compose exec -T api python scripts/generate_tsr.py \
            --results-dir results/ \
            --codebase-sha ${{ github.sha }} \
            --environment test \
            --triggered-by github-actions \
            --output tsr.json \
            --pretty

          # Copy TSR to host
          docker compose exec -T api cat tsr.json > tsr.json

          # Extract TSR ID for later steps
          TSR_ID=$(cat tsr.json | python3 -c "import sys, json; print(json.load(sys.stdin)['id'])")
          echo "tsr_id=$TSR_ID" >> $GITHUB_OUTPUT

      - name: Upload TSR to API
        if: always()
        working-directory: ./ai-testing-resource
        run: |
          curl -X POST $TSR_API_URL/api/tsr \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.TSR_API_TOKEN }}" \
            -d @tsr.json \
            -f || echo "TSR upload failed (non-blocking)"

      - name: Check Go/No-Go Decision
        id: go_no_go
        working-directory: ./ai-testing-resource
        run: |
          # Get decision from TSR
          DECISION=$(cat tsr.json | python3 -c "import sys, json; print(json.load(sys.stdin)['go_no_go_decision'])")
          echo "decision=$DECISION" >> $GITHUB_OUTPUT

          if [ "$DECISION" = "no_go" ]; then
            echo "::error::Deployment blocked: NO-GO decision"

            # Extract blocking issues
            cat tsr.json | python3 -c "import sys, json; tsr = json.load(sys.stdin); [print(f'::error::{issue}') for issue in tsr.get('blocking_issues', [])]"
            exit 1
          elif [ "$DECISION" = "pending_review" ]; then
            echo "::warning::Manual approval required"
          else
            echo "::notice::GO decision - proceeding with deployment"
          fi

      - name: Upload TSR Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-summary-report
          path: |
            ai-testing-resource/tsr.json
            ai-testing-resource/results/*.xml

      - name: Cleanup
        if: always()
        working-directory: ./ai-testing-resource
        run: docker compose down -v

  deploy-staging:
    needs: test-and-evaluate
    if: github.ref == 'refs/heads/main' && needs.test-and-evaluate.outputs.decision == 'go'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Staging
        run: |
          echo "Deploying to staging..."
          # Add your deployment commands here
          # ./scripts/deploy-staging.sh

      - name: Run Smoke Tests
        run: |
          echo "Running staging smoke tests..."
          # pytest tests/smoke --env=staging

      - name: Notify Success
        if: success()
        run: |
          echo "âœ… Deployment to staging successful!"

  deploy-production:
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://your-app.com

    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Production
        run: |
          echo "Deploying to production..."
          # Add your deployment commands here
          # ./scripts/deploy-production.sh

      - name: Notify Success
        if: success()
        run: |
          echo "ðŸš€ Production deployment successful!"
