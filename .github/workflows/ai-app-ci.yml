name: AI Application CI/CD

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main]

env:
  TSR_API_URL: ${{ secrets.TSR_API_URL || 'http://localhost:5000' }}

jobs:
  test-and-evaluate:
    runs-on: ubuntu-latest
    outputs:
      decision: ${{ steps.go_no_go.outputs.decision }}
      tsr_id: ${{ steps.tsr.outputs.tsr_id }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git operations

      - name: Build Docker images
        working-directory: ./ai-testing-resource
        run: |
          # Use docker compose build - simpler, respects image names from compose files
          docker compose -f docker-compose.yml -f docker-compose.ci.yml build

      - name: Start Docker Compose services
        working-directory: ./ai-testing-resource
        run: |
          cp .env.docker .env
          echo "ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}" >> .env
          # --no-build prevents rebuilding since we already built
          docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d --no-build

      - name: Show initial container logs
        if: always()
        working-directory: ./ai-testing-resource
        run: |
          echo "=== Container Status ==="
          docker compose ps
          echo ""
          echo "=== API Container Logs (last 50 lines) ==="
          docker compose logs --tail=50 api || true
          echo ""
          echo "=== Waiting 10 seconds for startup ==="
          sleep 10
          echo "=== API Container Logs After 10s (last 100 lines) ==="
          docker compose logs --tail=100 api || true

      - name: Wait for services to be healthy
        working-directory: ./ai-testing-resource
        run: |
          echo "Waiting for all services to be healthy..."
          timeout 120 bash -c 'until [ $(docker compose ps --format json | jq -r "select(.Health == \"healthy\") | .Name" | wc -l) -eq 3 ]; do echo "Waiting for all 3 services to be healthy..."; docker compose ps; sleep 5; done'
          echo "All services are healthy!"
          docker compose ps

      - name: Run tests in API container
        working-directory: ./ai-testing-resource
        run: |
          echo "Running pytest in container..."
          docker compose exec -T api pytest tests/ \
            --junitxml=results/test-results.xml \
            -v \
            --tb=short

      - name: Generate TSR from test results
        id: tsr
        working-directory: ./ai-testing-resource
        run: |
          docker compose exec -T api python scripts/generate_tsr.py \
            --results-dir results/ \
            --codebase-sha ${{ github.sha }} \
            --environment test \
            --triggered-by github-actions \
            --output tsr.json \
            --pretty

          # Copy TSR to host
          docker compose exec -T api cat tsr.json > tsr.json

          # Extract TSR ID
          TSR_ID=$(cat tsr.json | python3 -c "import sys, json; print(json.load(sys.stdin)['id'])")
          echo "tsr_id=$TSR_ID" >> $GITHUB_OUTPUT

      - name: Upload TSR to API
        if: always()
        working-directory: ./ai-testing-resource
        run: |
          curl -X POST $TSR_API_URL/api/tsr \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.TSR_API_TOKEN }}" \
            -d @tsr.json \
            -f || echo "TSR upload failed (non-blocking)"

      - name: Check Go/No-Go Decision
        id: go_no_go
        working-directory: ./ai-testing-resource
        run: |
          # Get decision from TSR
          DECISION=$(cat tsr.json | python3 -c "import sys, json; print(json.load(sys.stdin)['go_no_go_decision'])")
          echo "decision=$DECISION" >> $GITHUB_OUTPUT

          if [ "$DECISION" = "no_go" ]; then
            echo "::error::Deployment blocked: NO-GO decision"

            # Extract blocking issues
            cat tsr.json | python3 -c "import sys, json; tsr = json.load(sys.stdin); [print(f'::error::{issue}') for issue in tsr.get('blocking_issues', [])]"
            exit 1
          elif [ "$DECISION" = "pending_review" ]; then
            echo "::warning::Manual approval required"
          else
            echo "::notice::GO decision - proceeding with deployment"
          fi

      - name: Upload TSR Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-summary-report
          path: |
            ai-testing-resource/tsr.json
            ai-testing-resource/results/*.xml

      - name: Cleanup
        if: always()
        working-directory: ./ai-testing-resource
        run: docker compose down -v

  deploy-staging:
    needs: test-and-evaluate
    if: github.ref == 'refs/heads/main' && needs.test-and-evaluate.outputs.decision == 'go'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for OIDC

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::671388079324:role/github-actions-terraform-bootstrap
          aws-region: us-east-1

      - name: Verify AWS credentials
        run: aws sts get-caller-identity

      - name: Deploy to Staging
        run: |
          echo "Deploying to staging..."
          # Add your deployment commands here
          # ./scripts/deploy-staging.sh

      - name: Run Smoke Tests
        run: |
          echo "Running staging smoke tests..."
          # pytest tests/smoke --env=staging

      - name: Notify Success
        if: success()
        run: |
          echo "âœ… Deployment to staging successful!"

  deploy-production:
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for OIDC
    environment:
      name: production
      url: https://your-app.com

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::671388079324:role/github-actions-terraform-bootstrap
          aws-region: us-east-1

      - name: Verify AWS credentials
        run: aws sts get-caller-identity

      - name: Deploy to Production
        run: |
          echo "Deploying to production..."
          # Add your deployment commands here
          # ./scripts/deploy-production.sh

      - name: Notify Success
        if: success()
        run: |
          echo "ðŸš€ Production deployment successful!"
